# 実行モデル

## 概要

FILLYスクリプト（Toffyスクリプト）の実行モデルについて説明します。
FILLYはイベント駆動型のスクリプト言語であり、スレッドベースの実行モデルを採用しています。

---

## 1. FILLYの実行モデル: スレッドベースのイベント処理

### 基本概念

FILLYはスレッドベースの実行モデルを採用しています。`mes(EVENT_TYPE){...}` 構文は単なるイベントハンドラの登録ではなく、**イベントを待ち受けるスレッドの起動**を意味します。

### スレッドの種類

| スレッド | 説明 |
|---|---|
| **メインスレッド** | スクリプトを上から順に実行するスレッド |
| **イベントハンドラ** | `mes(EVENT_TYPE){...}` で登録され、イベント発生時に呼び出される |

### 実行フローの例

```toffy
// y-saru.tfy の構造
mes(MIDI_TIME){        // ← MIDI_TIMEイベントハンドラを登録
    step(8){
        // MIDIのテンポに合わせて実行される処理
        MovePic(...);,
        MovePic(...);,
        ...
        CloseWin(0);,
        CloseWin(1);,
        CloseWin(2);,
    }
}
PlayMIDI("FLYINSKY.mid");  // ← メインスレッドでMIDI再生開始
del_me;                     // ← メインスレッド自身を終了
```

### 設計原則

- **イベント駆動**: すべての処理はイベントループを中心に動作
- **非同期処理**: オーディオ再生は非同期で実行
- **テスト可能性**: ヘッドレスモードでGUIなしでテスト可能
- **エラー耐性**: 致命的でないエラーは記録して実行継続

---

## 2. mes()の動作原理

### ハンドラ登録

`mes()` はイベントハンドラを登録する構文です。

1. **`mes(MIDI_TIME){...}`** を実行すると、MIDI_TIMEイベントハンドラが登録される
2. メインスレッドは `mes{}` ブロックの後の処理に進む（ブロック内はすぐには実行されない）
3. 対応するイベントが発生すると、登録済みのハンドラが呼び出される

### step()の完了時動作

#### step()を持つハンドラ（StepCounter > 0）

- step内の全処理が完了したら、ハンドラは**自動的に削除**される
- 次のイベントが来ても、このハンドラは呼ばれない
- 例: `mes(MIDI_TIME){step(8){...}}` → step(8)の全処理完了後に削除

#### step()を持たないハンドラ（StepCounter == 0）

- 処理完了後、`CurrentPC = 0` にリセットされる
- ハンドラは**削除されない**
- 次のイベントが来たら、最初から再実行される
- 例: `mes(LBDOWN){...}` → クリックのたびに最初から実行

#### 実装コード

```go
// pkg/vm/event.go Execute()
if eh.StepCounter > 0 {
    // step()ブロック完了 → ハンドラを削除
    eh.Remove()
} else {
    // step()無しのハンドラ → 次のイベントに備えてリセット
    eh.CurrentPC = 0
}
```

### step()のカウンタ仕様

`StepCounter` は `step(n)` の `n` を保持します。これはカンマ1つあたりに待機するイベント数を表します。

| コンテキスト | カンマ1つの意味 |
|---|---|
| `mes(TIME)` 内 | n × 50ms（n回のTIMEイベント） |
| `mes(MIDI_TIME)` 内 | n回のMIDI_TIMEイベント |

### del_me / del_us / del_all の挙動

#### del_me

`del_me` は呼び出したコンテキストによって動作が異なります。

| 呼び出し場所 | 動作 |
|---|---|
| `mes{}` ブロックの**外** | **メインスレッドが終了** |
| `mes{}` ブロックの**中** | **そのイベントハンドラが削除** |

この違いは重要です。メインスレッドで `del_me` を呼ぶとメインスレッドの実行が停止し、イベントハンドラ内で呼ぶとそのハンドラのみが削除されます。

#### del_all

`del_all` は登録されている**すべてのイベントハンドラを削除**します。

---

## 3. プログラム実行順序

VMがOpCodeシーケンスを実行する際、以下の3フェーズで処理を行います。この順序は、グローバル変数が `main()` 関数内で正しく参照できることを保証するために重要です。

### Phase 1: 初期化

```
┌─────────────────────────────────────────────────────────────┐
│                    Phase 1: 初期化                          │
│                                                             │
│  1. グローバル変数の初期化 (OpAssign)                        │
│     - トップレベルの変数宣言を実行                           │
│     - 配列の初期化を含む                                    │
│                                                             │
│  2. 関数定義の収集 (OpDefineFunction)                       │
│     - ユーザー定義関数を関数テーブルに登録                   │
│                                                             │
│  3. イベントハンドラの登録 (OpRegisterEventHandler)          │
│     - mes()ブロックをイベントシステムに登録                  │
└─────────────────────────────────────────────────────────────┘
```

### Phase 2: main()実行

```
┌─────────────────────────────────────────────────────────────┐
│                    Phase 2: main()実行                      │
│                                                             │
│  4. main()関数の呼び出し                                    │
│     - グローバル変数は既に初期化済み                         │
│     - 関数定義は既に登録済み                                │
└─────────────────────────────────────────────────────────────┘
```

### Phase 3: イベントループ

```
┌─────────────────────────────────────────────────────────────┐
│                    Phase 3: イベントループ                   │
│                                                             │
│  5. イベントループの開始                                    │
│     - TIMEイベント、MIDI_TIMEイベント等を処理               │
│     - 登録されたハンドラを実行                              │
└─────────────────────────────────────────────────────────────┘
```

### 実行順序の重要性

グローバル変数の初期化が `main()` 関数の呼び出しより前に行われることで、以下のようなコードが正しく動作します。

```toffy
// グローバル配列の宣言と初期化
array[0] = 10
array[1] = 20
array[2] = 30

main() {
    // main()内でグローバル配列にアクセス
    x = array[0]  // x = 10
    y = array[1]  // y = 20
}
```

もしグローバル変数の初期化が `main()` の後に行われると、`main()` 内で配列にアクセスした際に「Array index out of range」エラーが発生します。

### 実装詳細

VMの `collectFunctionDefinitions` メソッドは、OpCodeシーケンスを走査して以下の処理を行います。

1. **OpAssign**: グローバル変数への代入を実行
2. **OpDefineFunction**: 関数定義を関数テーブルに登録
3. **OpRegisterEventHandler**: イベントハンドラをイベントシステムに登録

これらの処理が完了した後、VMは `main()` 関数を呼び出します。

---

## 4. イベントタイプ定数一覧

VMは初期化時に以下のイベントタイプ定数をグローバルスコープに登録します。
これにより、スクリプトから `PostMes(USER, ...)` のようにイベントタイプを参照できます。

| 定数名 | 値 | 説明 |
|--------|-----|------|
| `TIME` | 0 | タイマーイベント（50ms間隔） |
| `MIDI_TIME` | 1 | MIDIティックイベント |
| `MIDI_END` | 2 | MIDI再生終了イベント |
| `KEY` | 3 | キーボード入力イベント |
| `CLICK` | 4 | マウス左ボタン離し（クリック完了）イベント |
| `LBDOWN` | 4 | マウス左ボタン押下イベント |
| `RBDOWN` | 5 | マウス右ボタン押下 |
| `RBDBLCLK` | 6 | マウス右ボタンダブルクリック |
| `USER` | 7 | ユーザー定義イベント |

### CLICKとLBDOWNの違い

`CLICK` と `LBDOWN` は同じ定数値（4）を持ちますが、イベントとしては異なります。

| イベント | 発生タイミング |
|---|---|
| **LBDOWN** | マウス左ボタンを**押し下げた瞬間**に発生 |
| **CLICK** | マウス左ボタンを**離した瞬間**に発生（クリック完了） |

### イベントパラメータ

イベントハンドラ内では、以下のパラメータにアクセスできます。

| パラメータ | 説明 |
|---|---|
| `MesP1` | イベントパラメータ1 |
| `MesP2` | イベントパラメータ2 |
| `MesP3` | イベントパラメータ3 |
| `MesP4` | イベントパラメータ4 |
| `MessageType` | イベントタイプ番号 |

---

## 5. 動的スコープの仕様

FILLYは**動的スコープ**を採用しています。イベントハンドラ内から呼び出された関数は、呼び出し元のスコープにある変数にアクセスできます。

### 問題の背景

以下のようなコードで、`start()` 関数内で宣言された配列 `p2[]` を、イベントハンドラから呼び出された `Scene1ON()` 関数内でアクセスする必要があります。

```toffy
// 配列パラメータの参照渡し例
start() {
    int p1[], p2[], c1[], c2[];  // ローカル配列を宣言

    mes(MIDI_TIME) {
        step(8) {
            Scene1ON(p2[], c2[]);,  // 別ファイルの関数を呼び出し
            ...
        }
    }

    PlayMIDI("music.mid");
}

// SCENE1.TFY
Scene1ON(int p[], int c[]) {
    MovePic(p[0], ...);  // p2[]の値を使用
}
```

### 実装の詳細

#### 1. イベントハンドラの ParentScope

イベントハンドラは登録時のスコープを `ParentScope` として保持します。これにより、ハンドラ実行時に `start()` 関数のローカル変数（`p2[]` など）にアクセスできます。

#### 2. 関数呼び出し時のスコープチェーン

`callUserFunction()` は `NewScope(vm.GetCurrentScope())` で新しいスコープを作成します。これにより、呼び出し元のスコープ（イベントハンドラの `ParentScope`）が親スコープとなり、変数解決時に参照されます。

#### 3. PopStackFrame() でのスコープ復元

関数から戻る際、コールスタックが空になった場合でも、イベントハンドラ実行中であれば `currentHandler.ParentScope` を `vm.localScope` に復元します。これにより、同じハンドラ内の後続の関数呼び出しでも正しくスコープチェーンが維持されます。

### 実装コード

```go
// pkg/vm/vm.go PopStackFrame()
func (vm *VM) PopStackFrame() (*StackFrame, error) {
    // ... スタックフレームをポップ ...

    if len(vm.callStack) > 0 {
        vm.localScope = vm.callStack[len(vm.callStack)-1].LocalScope
    } else {
        // コールスタックが空になった場合、イベントハンドラの
        // ParentScopeを復元して動的スコープを維持
        if vm.currentHandler != nil && vm.currentHandler.ParentScope != nil {
            vm.localScope = vm.currentHandler.ParentScope
        } else {
            vm.localScope = nil
        }
    }

    return frame, nil
}
```

### この設計により解決される問題

- 別ファイルで定義された関数から、呼び出し元のローカル変数にアクセス可能
- イベントハンドラ内で複数の関数を連続して呼び出しても、スコープが正しく維持される
- FILLYの動的スコープセマンティクスを正確に再現

### 変数解決の優先順位

変数を参照する際、以下の順序で検索されます。

1. **ローカルスコープ**（現在の関数のスコープ）
2. **親スコープ**（スコープチェーンを辿る）
3. **グローバルスコープ**

ローカルスコープとグローバルスコープの両方に同名の変数が存在する場合、ローカルスコープの値が優先されます。

---

## 6. タイトル終了条件

タイトル（FILLYプログラム）は以下の条件で終了します。

### 終了トリガー

| 条件 | 動作 |
|---|---|
| `ExitTitle()` が呼ばれた場合 | 即座にタイトル終了 |
| ユーザーがEscキーを押した場合 | 即座にタイトル終了 |
| ユーザーがウィンドウの閉じるボタンをクリックした場合 | 即座にタイトル終了 |
| タイムアウトが設定されている場合 | 指定時間経過後にタイトル終了 |

### 重要な設計原則

#### タイトル終了後もウィンドウは開いたまま

スクリプトの実行が完了しても、仮想デスクトップウィンドウは閉じません。ユーザーが明示的に終了操作（Escキーまたはウィンドウを閉じる）を行うまで表示を継続します。これにより、MIDI再生が最後まで完了することを保証します。

#### 自動終了しない

全てのイベントハンドラが削除されても自動終了しません。MIDI再生の有無に関わらず、ユーザー操作まで待機します。

#### オーディオバッファの完全再生

MIDI再生終了時、オーディオバッファに残っている音声データが全て再生されるまで待機します。

### 設計変更の理由

- Ebitengineのオーディオバッファに残っている音声データが全て再生されるまで待機する必要がある
- オーディオバッファの状態を正確に検出するAPIがないため、ユーザー操作による終了に変更
- ユーザーは音楽が終わったことを確認してから終了操作を行える

### 旧実装との比較

| 項目 | 旧実装（_old_implementation2） | 現在の実装 |
|---|---|---|
| ハンドラ登録方式 | `mes(TIME)` / `mes(MIDI_TIME)` は **Sequencer** として登録 | **EventHandler** として登録 |
| 終了判定 | `AllSequencesComplete()` で判定 | **自動終了しない** |
| 終了条件 | アクティブなシーケンスが存在する限り実行継続 | ユーザーがEscキーを押すかウィンドウを閉じるまで継続 |
| ウィンドウ状態 | 終了判定に使用しない | ユーザー操作による終了を待機 |
