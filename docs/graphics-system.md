# 描画システム (Graphics System)

## 概要

FILLYエミュレータの描画システムについて説明します。
描画システムは、Ebitengineを使用してピクチャー管理、ウィンドウ管理、テキスト描画、描画プリミティブを提供します。

すべての描画要素（ウィンドウ、キャスト、テキスト、図形）はスプライトとして管理されます。
スプライトシステムの詳細については [スプライトシステム](sprite-system.md) を参照してください。

### 主要機能

| 機能 | 説明 |
|------|------|
| **ピクチャーシステム** | 画像データの読み込み、生成、転送 |
| **ウィンドウシステム** | 仮想ウィンドウの管理（WindowSpriteを使用） |
| **テキストシステム** | 文字列描画（TextSpriteを使用） |
| **描画プリミティブ** | 基本図形描画（ShapeSpriteを使用） |
| **描画コマンドキュー** | メインスレッド制約への対応 |

### 設計原則

- **スプライトベース**: すべての描画要素をスプライトとして統一管理
- **メインスレッド制約**: Ebitengineの描画APIはメインスレッドでのみ呼び出し可能
- **コマンドキュー**: イベントハンドラからの描画はキューイングして実行
- **リソース管理**: 明示的な解放とID再利用
- **エラー耐性**: 致命的でないエラーは記録して継続

---

## 1. Ebitengineメインスレッド制約と描画コマンドキュー

### メインスレッド制約

**重要**: Ebitengineの描画API（`ebiten.Image`への描画操作）はメインスレッドでのみ呼び出し可能です。VMのイベントハンドラ（`mes()`ブロック）は別のコンテキストで実行されるため、直接描画APIを呼び出すことはできません。

### アーキテクチャ

この制約に対応するため、描画コマンドキューを採用しています。

```
┌─────────────────────────────────────────────────────────────────┐
│                     メインスレッド (Ebitengine)                   │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │  Update()   │ -> │   Draw()    │ -> │  Layout()   │         │
│  │             │    │             │    │             │         │
│  │ 1. VMイベント│    │ 1. キュー   │    │ スケーリング │         │
│  │    処理     │    │    処理     │    │             │         │
│  │ 2. オーディオ│    │ 2. ウィンドウ│    │             │         │
│  │    更新     │    │    描画     │    │             │         │
│  │ 3. 入力処理 │    │ 3. キャスト │    │             │         │
│  │             │    │    描画     │    │             │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
└─────────────────────────────────────────────────────────────────┘
         ↑                    ↑
         │                    │
    コマンド追加          コマンド実行
         │                    │
┌────────┴────────────────────┴───────────────────────────────────┐
│                    描画コマンドキュー                             │
│                   (スレッドセーフ)                               │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐              │
│  │MovePic  │→│PutCast  │→│TextWrite│→│DrawRect │→ ...         │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘              │
└─────────────────────────────────────────────────────────────────┘
         ↑
         │ Push (どのスレッドからでも可)
         │
┌────────┴────────────────────────────────────────────────────────┐
│                    VMイベントハンドラ                            │
│                   (mes()ブロック)                               │
│                                                                 │
│  mes(MIDI_TIME) {                                               │
│      MovePic(...);  // → キューにPush                           │
│      PutCast(...);  // → キューにPush                           │
│  }                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 処理フロー

1. **VMイベントハンドラ**が描画関数（MovePic、PutCast等）を呼び出す
2. 描画関数は**実際の描画を行わず**、コマンドをキューにPushする
3. Ebitengineの**Draw()メソッド**（メインスレッド）でキューからコマンドを取り出し実行
4. 実際の`ebiten.Image`への描画はDraw()内でのみ行われる

### コマンドキューの設計

コマンドキューはスレッドセーフなFIFOキューとして実装されています。

| 操作 | 説明 |
|------|------|
| `Push(cmd)` | コマンドをキューに追加（どのスレッドからでも可） |
| `PopAll()` | すべてのコマンドを取り出し（Draw()内で呼び出し） |

**コマンドタイプ一覧**:

| コマンド | 説明 |
|----------|------|
| `CmdMovePic` | ピクチャー間の画像転送 |
| `CmdMoveSPic` | 拡大縮小転送 |
| `CmdTransPic` | 透明色除外転送 |
| `CmdReversePic` | 左右反転転送 |
| `CmdOpenWin` | ウィンドウを開く |
| `CmdMoveWin` | ウィンドウを移動 |
| `CmdCloseWin` | ウィンドウを閉じる |
| `CmdPutCast` | キャストを配置 |
| `CmdMoveCast` | キャストを移動 |
| `CmdDelCast` | キャストを削除 |
| `CmdTextWrite` | テキストを描画 |
| `CmdDrawLine` | 直線を描画 |
| `CmdDrawRect` | 矩形を描画 |
| `CmdFillRect` | 矩形を塗りつぶし |
| `CmdDrawCircle` | 円を描画 |

### システム構成

```
┌─────────────────────────────────────────────────────────────────┐
│                        Application                               │
│                      (pkg/app/app.go)                           │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Game Loop (Ebitengine)                      │
│                    (pkg/window/window.go)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   Update()   │  │    Draw()    │  │   Layout()   │          │
│  │  - VM Event  │  │  - Sprite    │  │  - Scaling   │          │
│  │  - Audio     │  │    Manager   │  │              │          │
│  │  - Input     │  │    Draw()    │  │              │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└────────────────────────────┬────────────────────────────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│  Graphics       │  │  Sprite         │  │  Command        │
│  System         │  │  System         │  │  Queue          │
│  (pkg/graphics) │  │  (pkg/sprite)   │  │                 │
│                 │  │  [実装済み]     │  │                 │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

**依存関係**:
- `pkg/graphics` → `pkg/sprite`（graphicsがspriteを使用）
- `pkg/vm` → `pkg/graphics`（VMがgraphicsを使用）
- `pkg/sprite` は独立したパッケージ（graphicsに依存しない）

### 並行性の保証

| コンポーネント | ロック方式 | 説明 |
|----------------|-----------|------|
| CommandQueue | `sync.Mutex` | Push/PopAllのスレッドセーフ性 |
| PictureManager | `sync.RWMutex` | 読み書きの並行制御 |
| WindowManager | `sync.RWMutex` | 読み書きの並行制御 |
| GraphicsSystem | `sync.RWMutex` | 描画状態の保護 |

---

## 2. ウィンドウ装飾の仕様

### 概要

仮想ウィンドウはWindows 3.1風の装飾で描画されます。装飾は `WindowSprite` が担当します。

### 装飾の定数

| 定数 | 値 | 説明 |
|------|-----|------|
| `BorderThickness` | 4 | 外枠の幅（ピクセル） |
| `TitleBarHeight` | 20 | タイトルバーの高さ（ピクセル） |

### 装飾の色

| 要素 | 色 | RGB値 |
|------|-----|-------|
| タイトルバー | 濃い青 | `(0, 0, 128)` |
| 外枠背景 | グレー | `(192, 192, 192)` |
| ハイライト（立体効果） | 白 | `(255, 255, 255)` |
| 影（立体効果） | 黒 | `(0, 0, 0)` |

### 装飾の構成

1. **外枠**: グレーの背景に3D効果（上と左に白いハイライト、下と右に黒い影）
2. **タイトルバー**: 濃い青（#000080）の矩形、高さ20ピクセル
3. **コンテンツ領域**: ピクチャーが表示される領域

### 座標計算

ウィンドウの全体サイズとコンテンツ領域の関係は以下の通りです。

| 項目 | 計算式 |
|------|--------|
| ウィンドウ全体の幅 | コンテンツ幅 + `BorderThickness` × 2 |
| ウィンドウ全体の高さ | コンテンツ高さ + `BorderThickness` × 2 + `TitleBarHeight` |
| コンテンツ領域X | `win.X` + `BorderThickness` |
| コンテンツ領域Y | `win.Y` + `BorderThickness` + `TitleBarHeight` |

### 描画順序

1. グレーの背景を全体に描画
2. 3D枠線効果を描画（`vector.StrokeLine`を使用）
3. タイトルバーを描画
4. コンテンツ領域にピクチャーを描画

### 位置指定なしの場合のセンタリング

`OpenWin`で位置指定（x, y引数）がない場合、ウィンドウを仮想デスクトップの中央に配置します。

| 条件 | 動作 |
|------|------|
| 位置指定なし | 仮想デスクトップの中央に配置 |
| 明示的に(0, 0)を指定 | センタリングしない（左上に配置） |

センタリング計算では、ウィンドウ装飾（枠とタイトルバー）を含めた全体サイズを考慮します。

---

## 3. テキスト描画

### 概要

テキスト描画は、フォント設定の管理と `TextSprite` の作成を担当します。FILLYスクリプト特有のテクニック（差分抽出方式、OriginalImage、大フォント塗りつぶし）に対応しています。

### 差分抽出方式

FILLYスクリプトでは、同じ位置に異なる色でテキストを描画することがあります（例：黒で描画後、白で上書き）。通常のアルファブレンディングでは、前のテキストのアンチエイリアス部分が「影」として残ってしまいます。

この問題を解決するため、差分抽出方式を採用しています。

#### 処理フロー

```
1. 背景色で塗りつぶした一時画像を作成
2. 一時画像にテキストを描画（アンチエイリアスあり）
3. 背景色と異なるピクセルのみを抽出
4. 抽出結果を透過画像としてスプライト化
```

#### 差分抽出のアルゴリズム

```
各ピクセルについて:
  IF 背景画像のピクセル色 ≠ テキスト描画後のピクセル色 THEN
    → テキスト描画後の色をそのまま採用
  ELSE
    → 透明（RGBA(0, 0, 0, 0)）にする
```

この方式により、テキスト部分のみが透過画像として抽出され、背景色のピクセルは含まれません。同じ位置に別の色でテキストを描画しても、前のテキストの影が残りません。

### OriginalImage

`Picture`構造体には`OriginalImage`フィールドがあります。これはテキスト描画時のアンチエイリアス影問題を解決するために追加されたフィールドです。

| フィールド | 型 | 説明 |
|------------|-----|------|
| `Image` | `*ebiten.Image` | 現在の画像（テキスト描画後） |
| `OriginalImage` | `*image.RGBA` | 元の背景画像（テキスト描画前） |

- `LoadPic`/`CreatePic`時に元の画像をRGBAとして保存
- `TextWrite`では、この`OriginalImage`を基準に差分を取ることで、同じ位置に別の色でテキストを描画しても前のテキストの影が残らない

### 大フォントサイズによるピクチャー塗りつぶしテクニック

FILLYスクリプトでは、大きなフォントサイズ（例: 640）を設定して`TextWrite`を呼び出すことで、ピクチャー全体を背景色で塗りつぶすテクニックが使用されることがあります。

```toffy
// FILLYスクリプトの例
SetFont(640, ...);
BgColor(0xFFFFFF);  // 白
TextWrite("  ", pic, 0, 0);  // ピクチャー全体を白で塗りつぶす
```

#### 実装方針

| フォントサイズ | 動作 |
|----------------|------|
| 200以下 | 通常のテキスト描画 |
| 200超 | ピクチャー全体を背景色で塗りつぶし |

- `SetFont`では元のサイズを保持する（背景塗りつぶし判定用）
- 実際のフォント描画には制限されたサイズ（最大72）を使用
- `TextWrite`でフォントサイズが200を超える場合、ピクチャー全体を背景色で塗りつぶす

### 二重描画の禁止

`TextWrite`で以下の2つの処理を同時に行うと、テキストが1ドットずれて二重に描画され、滲んで見える問題が発生します。

| 処理 | 説明 |
|------|------|
| Pictureに直接焼き付け | `TextRenderer.TextWrite()`でPictureに描画 |
| TextSpriteを作成 | `TextSpriteManager.CreateTextSprite()`でスプライト作成 |

**原因**: PictureSpriteの画像にテキストが焼き付けられ、さらにTextSpriteとして同じテキストが描画されるため、微妙な位置ずれにより二重に見える。

**解決策**: TextSpriteを使用する場合は、Pictureへの焼き付けを行わない。TextSpriteのみを作成する。

### 日本語フォント対応

FILLYスクリプトではWindows用フォント（MSゴシック、MS明朝等）が指定されますが、macOSやLinuxには存在しないため、フォールバック機能を実装しています。

| Windowsフォント | macOSフォールバック | Linuxフォールバック |
|-----------------|---------------------|---------------------|
| MSゴシック / MS Pゴシック | Hiragino Kaku Gothic Pro | Noto Sans JP / IPAGothic |
| MS明朝 / MS P明朝 | Hiragino Mincho Pro | Noto Serif JP / IPAMincho |

フォント名は全角・半角スペース、大文字・小文字の違いを吸収して正規化されます。すべてのフォールバック候補が見つからない場合は、埋め込みフォント（Noto Sans JP）を使用します。

---

## 4. RLE圧縮BMPデコーダー

### 背景

Go標準ライブラリの`image/bmp`はRLE圧縮をサポートしていないため、カスタムデコーダーを実装しています（`pkg/graphics/bmp.go`）。

### サポートする圧縮方式

| 圧縮方式 | 値 | 説明 |
|----------|-----|------|
| BI_RGB | 0 | 非圧縮（標準デコーダーを使用） |
| BI_RLE8 | 1 | 8ビットRLE圧縮 |
| BI_RLE4 | 2 | 4ビットRLE圧縮 |

### RLE8デコードアルゴリズム

2バイトペアを読み取り、以下のルールでデコードします。

| 最初のバイト | 2番目のバイト | 動作 |
|-------------|--------------|------|
| 0以外（N） | 値V | 値Vを**N回**繰り返す |
| 0 | 0 | **行末** (End of Line) |
| 0 | 1 | **ビットマップ終了** (End of Bitmap) |
| 0 | 2 | **デルタ**（位置移動） |
| 0 | 3以上（N） | **絶対モード**: N個のピクセルをそのまま読み取る |

### RLE4デコードアルゴリズム

RLE8と同様のルールですが、1バイトに2ピクセル（上位4ビットと下位4ビット）が格納されます。

### LoadPicでの使用

BMPファイルを読み込む際、まずRLE圧縮かどうかを確認し、圧縮されている場合はカスタムデコーダーを使用します。

```
BMPファイル読み込み:
  1. BMPヘッダーを確認
  2. IF RLE圧縮 THEN
       → カスタムデコーダー (DecodeBMP) を使用
     ELSE
       → Go標準デコーダー (image.Decode) を使用
```

---

## 5. シーンチェンジの各モード

### 概要

`MovePic`のmode引数（2〜9）でシーンチェンジ効果を指定できます。シーンチェンジは、ソース画像を段階的に転送先に表示するアニメーション効果です。

### モード一覧

| モード | 定数名 | 説明 |
|--------|--------|------|
| 0 | `SceneChangeNone` | 通常コピー（シーンチェンジなし） |
| 1 | `SceneChangeTransparent` | 透明色除外コピー |
| 2 | `SceneChangeWipeDown` | 上から下へのワイプ |
| 3 | `SceneChangeWipeRight` | 左から右へのワイプ |
| 4 | `SceneChangeWipeLeft` | 右から左へのワイプ |
| 5 | `SceneChangeWipeUp` | 下から上へのワイプ |
| 6 | `SceneChangeWipeOut` | 中央から外側へのワイプ |
| 7 | `SceneChangeWipeIn` | 外側から中央へのワイプ |
| 8 | `SceneChangeRandom` | ランダムブロック |
| 9 | `SceneChangeFade` | フェード |

### 各モードの詳細

#### mode=2〜5: 方向ワイプ

進捗（0.0〜1.0）に応じて、指定方向からソース画像の領域を段階的に転送します。

| モード | 方向 | 動作 |
|--------|------|------|
| 2 | 上→下 | 上端から`currentHeight`までの領域を転送 |
| 3 | 左→右 | 左端から`currentWidth`までの領域を転送 |
| 4 | 右→左 | 右端から`currentWidth`までの領域を転送 |
| 5 | 下→上 | 下端から`currentHeight`までの領域を転送 |

#### mode=6: 中央から外側へのワイプ

画像の中央点を基準に、進捗に応じて矩形領域を拡大しながら転送します。

```
進捗0.0: 中央の1点のみ
進捗0.5: 中央から幅・高さの50%の矩形
進捗1.0: 画像全体
```

#### mode=7: 外側から中央へのワイプ

mode=6の逆方向。外側から中央に向かって矩形領域を縮小しながら転送します。

#### mode=8: ランダムブロック

画像を16×16ピクセルのブロックに分割し、ランダムな順序で段階的に転送します。

| 項目 | 値 |
|------|-----|
| ブロックサイズ | 16×16ピクセル |
| 描画順序 | ランダム（`rand.Perm`で生成） |
| 進捗管理 | 全ブロック数に対する描画済みブロック数の割合 |

#### mode=9: フェード

アルファ値を0.0から1.0に徐々に変化させ、ソース画像を透過的に重ねます。

### 速度調整

`speed`引数でシーンチェンジの速度を制御します。

| speed値 | 完了フレーム数 | 完了時間（60FPS） |
|---------|---------------|-------------------|
| 0（デフォルト） | 60フレーム | 約1秒 |
| 1 | 60フレーム | 約1秒 |
| 2 | 30フレーム | 約0.5秒 |
| N | 60/Nフレーム | 約1/N秒 |

---

## 6. MoveCast/MovePicの複数引数形式の実装

MoveCastとMovePicは複数の引数形式をサポートしています。
各形式の引数仕様については [言語仕様 - MoveCast](language-spec.md#movecast) および
[言語仕様 - MovePic](language-spec.md#movepic) を参照してください。

ここでは、引数の数に応じた実装上の分岐ロジックについて説明します。

### MoveCast の引数数による分岐

| 引数数 | 更新されるフィールド |
|--------|---------------------|
| 3 | 位置のみ |
| 4 | ピクチャー + 位置 |
| 7 | 位置 + ソース領域 |
| 8 | ピクチャー + 位置 + ソース領域 |
| 9 | 全フィールド（ピクチャー + 位置 + 透明色 + ソース領域） |

9引数形式は、アニメーションでキャストの画像を切り替えながら移動させる場合に使用されます。

### MovePic の引数数による分岐

| 引数数 | 動作 | デフォルト値 |
|--------|------|-------------|
| 2 | ソースピクチャー全体を転送 | dst_x=0, dst_y=0, mode=0 |
| 6 | ソース領域を指定して転送 | dst_x=0, dst_y=0, mode=0 |
| 8 | ソース領域と転送先位置を指定 | mode=0 |
| 9 | 標準形式（転送モード指定） | — |
| 10 | シーンチェンジ速度指定 | — |

---

## 座標系

本システムでは以下の4つの座標系を使用します。

### 座標系の種類

| 座標系 | 原点 | 用途 |
|--------|------|------|
| **仮想デスクトップ座標系** | 仮想デスクトップの左上 (0, 0) | ウィンドウの位置 |
| **ウィンドウコンテンツ座標系** | コンテンツ領域の左上 | ウィンドウ内の描画要素の基準位置 |
| **ピクチャー座標系** | ピクチャー画像の左上 (0, 0) | キャスト、テキスト、図形の位置 |
| **スクリーン座標系** | 実際のウィンドウの左上 (0, 0) | 最終的な描画位置 |

### 座標変換の流れ

```
ピクチャー座標 (x, y)
      ↓
PicX/PicYオフセット適用: (x - PicX, y - PicY)
      ↓
コンテンツ領域オフセット適用: (contentX + x - PicX, contentY + y - PicY)
      ↓
スクリーン座標 (screenX, screenY)
```

### PicX/PicYオフセット

| オフセット | 効果 |
|-----------|------|
| PicX > 0 | ピクチャーが左にシフト（右側が見える） |
| PicX < 0 | ピクチャーが右にシフト（左側が見える） |
| PicY > 0 | ピクチャーが上にシフト（下側が見える） |
| PicY < 0 | ピクチャーが下にシフト（上側が見える） |

座標変換のロジックは `pkg/graphics/coordinate.go` の `CoordinateConverter` に集約されており、オフセット処理の一貫性を保ち、二重適用を防いでいます。

---

## パッケージ構成

```
pkg/graphics/                  ← 描画システム本体
├── graphics.go                # GraphicsSystem（SpriteManagerを使用）
├── picture.go                 # Picture管理
├── window.go                  # Window管理（WindowSpriteと連携）
├── text.go                    # テキスト描画設定
├── text_sprite.go             # TextSprite（差分抽出方式）
├── transfer.go                # MovePic等の転送
├── primitives.go              # 描画プリミティブ（ShapeSpriteを使用）
├── bmp.go                     # RLE圧縮BMPデコーダー
├── queue.go                   # 描画コマンドキュー
├── scene_change.go            # シーンチェンジ
├── color.go                   # 色変換ユーティリティ
├── coordinate.go              # 座標変換
├── debug.go                   # デバッグオーバーレイ
└── fonts/
    └── NotoSansJP-Regular.ttf  # 埋め込みフォント（フォールバック用）
```
