# アーキテクチャドキュメント

## 概要

son-etは、レガシーなFILLYスクリプト（Toffyスクリプト）を実行するGoベースのインタプリタです。
スクリプトのコンパイル、仮想マシンによる実行、グラフィックス描画、オーディオ再生を統合的に提供します。

## 全体構成

```
┌─────────────┐
│  cmd/son-et  │  エントリーポイント
│   main.go    │
└──────┬───────┘
       │
┌──────▼───────┐
│   pkg/cli    │  コマンドライン引数解析
└──────┬───────┘
       │
┌──────▼───────┐
│   pkg/app    │  アプリケーション初期化・起動
└──────┬───────┘
       │
  ┌────┴────────────────┐
  │                     │
┌─▼──────────┐  ┌───────▼──────┐
│ pkg/compiler│  │   pkg/vm     │  スクリプトコンパイル → VM実行
└─────────────┘  └───────┬──────┘
                         │
              ┌──────────┼──────────┐
              │          │          │
       ┌──────▼───┐ ┌───▼────┐ ┌──▼──────────┐
       │pkg/graphics│ │pkg/vm/ │ │ pkg/sprite  │
       │           │ │ audio  │ │ pkg/window  │
       └───────────┘ └────────┘ └─────────────┘
```

## パッケージ詳細

### cmd/son-et
アプリケーションのエントリーポイント。CLIの初期化とアプリケーションの起動を行います。

### pkg/cli
コマンドライン引数の解析を担当。`--timeout`, `--headless`, `--log-level`等のオプションを処理します。

### pkg/app
アプリケーションの初期化と起動を担当。タイトルの選択、コンパイラの呼び出し、VMの起動を統括します。

### pkg/compiler
TFYスクリプトをOpCodeに変換するコンパイラ。4段階のパイプラインで処理します。

| サブパッケージ | 役割 |
|---|---|
| `preprocessor` | プリプロセッサ（インクルード展開等） |
| `lexer` | 字句解析（トークン化） |
| `parser` | 構文解析（AST生成） |
| `compiler` | OpCode生成 |

### pkg/vm
FILLYスクリプトのOpCodeを実行する仮想マシン。ビルトイン関数はカテゴリ別に分離されています。

| ファイル | 役割 |
|---|---|
| `vm.go` | VMコア（構造体定義、実行ループ、ビルトイン登録の統括） |
| `builtins_math.go` | 数学関数（Random等） |
| `builtins_string.go` | 文字列操作関数（StrPrint, StrCode, StrLen, SubStr, StrFind） |
| `builtins_array.go` | 配列操作関数 |
| `builtins_graphics.go` | グラフィックス関数（LoadPic, OpenWin, PutCast, TextWrite等） |
| `builtins_audio.go` | オーディオ関数（PlayMIDI, PlayWAVE） |
| `builtins_system.go` | システム関数（Wait, Debug, INIファイル操作等） |
| `executor.go` | OpCode実行エンジン |
| `event.go` | イベントハンドラ管理 |
| `scope.go` | 変数スコープ管理 |
| `array.go` | 配列データ構造 |
| `error.go` | エラー定義 |

### pkg/vm/audio
オーディオサブシステム。MIDIファイルの再生（ソフトウェアシンセサイザー経由）とWAVファイルの再生を担当します。

### pkg/graphics
グラフィックス描画システム。機能別に分離されています。

| ファイル | 役割 |
|---|---|
| `graphics_core.go` | コアシステム（GraphicsSystem構造体、初期化、更新、シャットダウン、ピクチャー操作） |
| `graphics_draw.go` | 描画ロジック（Draw、座標変換、テキスト描画、図形描画、転送処理） |
| `graphics_window.go` | ウィンドウ管理（OpenWin, CloseWin, MoveWin, CapTitle等） |
| `graphics_sprite.go` | スプライト管理（PutCast, MoveCast, DelCast、スプライト収集・更新） |
| `color_utils.go` | 色変換ユーティリティ（toIntFromAny等） |
| `sprite_sort.go` | スプライトソートユーティリティ（Z-orderソート） |
| `picture.go` | ピクチャー（画像）データ構造 |
| `window.go` | ウィンドウデータ構造 |
| `sprite.go` | スプライト基底型 |
| `cast_sprite.go` | キャストスプライト（ピクチャーから切り出した画像） |
| `picture_sprite.go` | ピクチャースプライト |
| `window_sprite.go` | ウィンドウスプライト |
| `shape_sprite.go` | 図形スプライト |
| `text_sprite.go` | テキストスプライト |
| `zpath.go` | Z-path（描画順序）管理 |
| `coordinate.go` | 座標変換 |
| `bmp.go` | BMPファイル読み込み |
| `scene_change.go` | シーンチェンジ効果 |
| `transfer.go` | ピクチャー転送処理 |
| `headless.go` | ヘッドレスモード対応 |

### pkg/sprite
スプライトシステムの抽象レイヤー。キャストスプライト、ピクチャースプライト、デバッグオーバーレイ等を提供します。

### pkg/window
ウィンドウシステム。仮想デスクトップ上のウィンドウ管理を担当します。

### pkg/fileutil
ファイルシステムユーティリティ。大文字小文字を区別しないファイル検索（Windows 3.1互換）等を提供します。

### pkg/script
スクリプトファイルの読み込みを担当。Shift-JISエンコーディングのTFYファイルを処理します。

### pkg/title
タイトル（プロジェクト）の管理を担当。ディレクトリからのタイトル検出と選択を行います。

### pkg/logger
構造化ログ出力を提供します。

### pkg/opcode
VMが実行するOpCode（命令コード）の定義を提供します。

## ヘッドレスモードの詳細仕様

### 概要

ヘッドレスモードは、グラフィカルディスプレイのない環境（サーバー、CI/CDパイプラインなど）でson-etを実行するためのモードです。
`--headless`フラグを指定することで有効化され、GUIウィンドウを一切開かずにスクリプトを実行します。

### ヘッドレスモードの動作原則

| 項目 | GUIモード | ヘッドレスモード |
|------|-----------|------------------|
| ウィンドウ表示 | Ebitengineウィンドウを作成 | ウィンドウを一切作成しない |
| タイトル選択 | GUI上のリスト選択 | 標準入出力によるテキスト選択 |
| 仮想デスクトップ | 1024x768ウィンドウ表示 | フェーズをスキップ |
| 描画操作 | 画面に描画 | スキップ（ログに記録） |
| オーディオ | 通常再生 | 初期化するがミュート |
| MIDI_TIMEイベント | 通常生成 | 通常通り生成（同期維持） |
| タイマーイベント | 通常生成 | 通常生成 |

### GUIウィンドウの完全排除

ヘッドレスモードでは、Ebitenゲームエンジンの初期化自体を行いません。

- `window.Run()` はGUIモード専用であり、ヘッドレスモードでは呼び出されない
- `window.RunHeadless()` がヘッドレスモード専用の関数として提供される
- `window.Run()` と `window.RunHeadless()` は相互排他的に呼び出される
- `runDesktop()` メソッドは、ウィンドウ作成関数を呼び出す前にヘッドレスフラグをチェックし、ヘッドレスモードでは即座にリターンする

### ヘッドレスモードでのタイトル選択

複数タイトルが利用可能な場合、標準入出力を使用したテキストベースの選択を行います。

- 利用可能なタイトルを標準出力に番号付きリストで表示
- 標準入力からユーザー入力（番号）を受け付ける
- 有効な番号が入力された場合、そのタイトルを選択して処理を続行
- 無効な入力の場合、エラーメッセージを表示して再度プロンプトを表示
- `q` または `Q` の入力でプログラムを正常終了

### ヘッドレスモードでの実行エンジン動作

ヘッドレスモードでも、実行エンジンの非GUI機能はすべて正常に動作します。

- **オーディオシステム**: 初期化されるが、すべての出力をミュート
- **MIDI再生**: テンポ情報の抽出とMIDI_TIMEイベントの生成は通常通り行われる（同期制御のため）
- **イベントシステム**: TIME、MIDI_TIME、MIDI_END、USERイベントは通常通り生成・ディスパッチされる
- **描画操作**: すべてスキップされるが、操作内容はログに記録される
- **スクリプト実行**: コンパイル、OpCode実行、変数管理、関数呼び出しはすべて通常通り動作

### 有効化方法

ヘッドレスモードは以下の方法で有効化できます：

1. コマンドラインフラグ: `--headless`
2. 環境変数による有効化（CI/CD環境向け）

## Ebitengine再初期化制約とモード遷移

### 制約の背景

Ebitengineは内部でGLFW（OpenGLウィンドウ管理ライブラリ）を使用しています。
GLFWの制約により、一度 `ebiten.RunGame()` が終了すると、同一プロセス内で再度 `ebiten.RunGame()` を呼び出すことができません。
再呼び出しを試みると「GLFW library is not initialized」エラーが発生します。

### 問題

複数のFILLYタイトルが埋め込まれている場合、以下のフローが必要です：

1. タイトル選択画面を表示（GUIウィンドウ）
2. ユーザーがタイトルを選択
3. 仮想デスクトップでタイトルを実行（GUIウィンドウ）
4. ESCキーでタイトル選択画面に戻る（GUIウィンドウ）

これを素朴に実装すると、各フェーズで `RunGame()` を呼び出すことになり、2回目以降の呼び出しでGLFWエラーが発生します。

### 解決策: 単一RunGame内でのモード遷移

タイトル選択とデスクトップ実行を、単一の `ebiten.RunGame()` 呼び出し内でモード遷移として処理します。

```
┌─────────────────────────────────────────────────────────────────┐
│                    単一のRunGame呼び出し                          │
│                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐                    │
│  │  ModeSelection  │ ⇄ │   ModeDesktop   │                    │
│  │  (タイトル選択)  │    │  (仮想デスクトップ) │                    │
│  └─────────────────┘    └─────────────────┘                    │
│                                                                 │
│  Enter押下 → ModeDesktop へ遷移                                  │
│  ESCキー  → ModeSelection へ戻る（複数タイトル時）                 │
│  ESCキー  → プログラム終了（単一タイトル時）                        │
└─────────────────────────────────────────────────────────────────┘
```

### モード遷移の状態管理

`Game` 構造体が `Mode` フィールドを持ち、`Update()` メソッド内でモードに応じた処理を切り替えます。

| 現在のモード | hasTitleSelection | ESCキー動作 |
|-------------|-------------------|-------------|
| ModeSelection | true | プログラム終了 |
| ModeDesktop | true | タイトル選択画面に戻る |
| ModeDesktop | false | プログラム終了 |

### ModeSelection → ModeDesktop 遷移フロー

1. ユーザーがタイトルを選択（Enterキー）
2. `onTitleSelected` コールバックが呼び出される
   - スクリプトの読み込みとコンパイル
   - VM / GraphicsSystem の初期化
   - `game.mode = ModeDesktop` に遷移
3. 次のフレームから `updateDesktop()` が呼び出される
4. 最初の `updateDesktop()` で `vmStartFunc()` が呼び出され、VMが開始

### ModeDesktop → ModeSelection 遷移フロー（ESCキー）

1. ESCキー押下を検出
2. `returnToSelection()` メソッドが呼び出される
   - VMを停止
   - `onTitleExit` コールバックでリソースクリーンアップ（GraphicsSystem、AudioSystem）
   - `game.mode = ModeSelection` に変更
   - VM関連フィールドをリセット
3. 次のフレームからタイトル選択画面が再表示される
4. `selectedIndex` は保持され、以前の選択位置が維持される

### VMの遅延開始

VMは `updateDesktop()` の最初の呼び出し時に開始されます。
これにより、Ebitengineが完全に初期化された後にVMが開始され、`ebiten.Image` の作成などが安全に行えます。

```go
func (g *Game) updateDesktop() error {
    if !g.vmStarted && g.vmStartFunc != nil {
        g.vmStarted = true
        g.vmStartFunc()  // VMをゴルーチンで開始
    }
    // ...
}
```

### リソース管理の注意点

- **オーディオコンテキスト**: Ebitengineのオーディオコンテキストは一度しか作成できないため、`Application` レベルで保持してタイトル切り替え時に再利用する
- **タイトル終了時のクリーンアップ**: VM停止、GraphicsSystemリセット、AudioSystem停止を確実に行う
- **エラーハンドリング**: リソース解放中のエラーはログに記録して処理を継続する
