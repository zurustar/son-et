package audio

import (
	"testing"
	"time"

	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"github.com/zurustar/son-et/pkg/vm"
)

// TestTimerIntervalProperty tests that the timer uses the configured interval.
// **Validates: Requirements 3.2, 3.3**
// Property: For any valid interval, the timer uses that interval for TIME event generation.
// For zero or negative intervals, the default interval (50ms) is used.
func TestTimerIntervalProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	properties.Property("timer uses configured interval or default for invalid intervals", prop.ForAll(
		func(intervalMs int64) bool {
			eventQueue := vm.NewEventQueue()
			interval := time.Duration(intervalMs) * time.Millisecond

			timer := NewTimer(interval, eventQueue)

			// Check that the interval is set correctly
			actualInterval := timer.GetInterval()

			if intervalMs <= 0 {
				// Should use default interval
				return actualInterval == DefaultTimerInterval
			}
			// Should use the specified interval
			return actualInterval == interval
		},
		gen.Int64Range(-100, 500),
	))

	properties.TestingRun(t)
}

// TestTimerStartStopProperty tests that Start and Stop are idempotent.
// **Validates: Requirements 3.1**
// Property: Multiple calls to Start or Stop do not cause errors or change state unexpectedly.
func TestTimerStartStopProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	properties.Property("start and stop are idempotent", prop.ForAll(
		func(startCount, stopCount int) bool {
			eventQueue := vm.NewEventQueue()
			timer := NewTimer(10*time.Millisecond, eventQueue)

			// Call Start multiple times
			for i := 0; i < startCount; i++ {
				timer.Start()
			}

			// Timer should be running if startCount > 0
			if startCount > 0 && !timer.IsRunning() {
				return false
			}

			// Call Stop multiple times
			for i := 0; i < stopCount; i++ {
				timer.Stop()
			}

			// Timer should not be running after Stop
			if stopCount > 0 && timer.IsRunning() {
				return false
			}

			// Clean up
			timer.Stop()
			return true
		},
		gen.IntRange(0, 5),
		gen.IntRange(0, 5),
	))

	properties.TestingRun(t)
}

// TestTimerEventTypeProperty tests that all generated events are TIME events.
// **Validates: Requirements 3.1, 3.4**
// Property: All events generated by the timer have type TIME.
func TestTimerEventTypeProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 50

	properties := gopter.NewProperties(parameters)

	properties.Property("all generated events are TIME events", prop.ForAll(
		func(waitMs int) bool {
			eventQueue := vm.NewEventQueue()
			timer := NewTimer(5*time.Millisecond, eventQueue)

			timer.Start()

			// Wait for some events
			time.Sleep(time.Duration(waitMs) * time.Millisecond)

			timer.Stop()

			// Check all events are TIME events
			for eventQueue.Len() > 0 {
				event, ok := eventQueue.Pop()
				if !ok {
					break
				}
				if event.Type != vm.EventTIME {
					return false
				}
			}

			return true
		},
		gen.IntRange(10, 50),
	))

	properties.TestingRun(t)
}

// TestTimerEventTimestampProperty tests that all events have valid timestamps.
// **Validates: Requirements 1.2, 3.4**
// Property: All events generated by the timer have timestamps within the timer's running period.
func TestTimerEventTimestampProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 50

	properties := gopter.NewProperties(parameters)

	properties.Property("all events have valid timestamps", prop.ForAll(
		func(waitMs int) bool {
			eventQueue := vm.NewEventQueue()
			timer := NewTimer(5*time.Millisecond, eventQueue)

			beforeStart := time.Now()
			timer.Start()

			// Wait for some events
			time.Sleep(time.Duration(waitMs) * time.Millisecond)

			timer.Stop()
			afterStop := time.Now()

			// Check all event timestamps are within the running period
			for eventQueue.Len() > 0 {
				event, ok := eventQueue.Pop()
				if !ok {
					break
				}
				// Allow small tolerance for timing
				if event.Timestamp.Before(beforeStart.Add(-time.Millisecond)) {
					return false
				}
				if event.Timestamp.After(afterStop.Add(time.Millisecond)) {
					return false
				}
			}

			return true
		},
		gen.IntRange(10, 50),
	))

	properties.TestingRun(t)
}

// TestTimerSetIntervalProperty tests that SetInterval correctly updates the interval.
// **Validates: Requirements 3.2**
// Property: After SetInterval is called, GetInterval returns the new interval (or default for invalid values).
func TestTimerSetIntervalProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	properties.Property("SetInterval correctly updates the interval", prop.ForAll(
		func(initialMs, newMs int64) bool {
			eventQueue := vm.NewEventQueue()
			initialInterval := time.Duration(initialMs) * time.Millisecond
			newInterval := time.Duration(newMs) * time.Millisecond

			timer := NewTimer(initialInterval, eventQueue)

			// Set new interval
			timer.SetInterval(newInterval)

			actualInterval := timer.GetInterval()

			if newMs <= 0 {
				// Should use default interval
				return actualInterval == DefaultTimerInterval
			}
			// Should use the new interval
			return actualInterval == newInterval
		},
		gen.Int64Range(1, 200),
		gen.Int64Range(-100, 500),
	))

	properties.TestingRun(t)
}

// TestTimerRunningStateProperty tests that the running state is consistent.
// **Validates: Requirements 3.1**
// Property: IsRunning returns true after Start and false after Stop.
func TestTimerRunningStateProperty(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	properties.Property("running state is consistent with Start/Stop calls", prop.ForAll(
		func(operations []bool) bool {
			eventQueue := vm.NewEventQueue()
			timer := NewTimer(10*time.Millisecond, eventQueue)

			expectedRunning := false

			for _, shouldStart := range operations {
				if shouldStart {
					timer.Start()
					expectedRunning = true
				} else {
					timer.Stop()
					expectedRunning = false
				}

				if timer.IsRunning() != expectedRunning {
					timer.Stop() // Clean up
					return false
				}
			}

			// Clean up
			timer.Stop()
			return true
		},
		gen.SliceOfN(10, gen.Bool()),
	))

	properties.TestingRun(t)
}
