# 要件定義書: OpCodeコンパイラ

## はじめに

このドキュメントは、FILLYスクリプト（.TFYファイル）をOpCodeに変換するコンパイラ機能の要件を定義します。son-etインタプリタは、スクリプトファイルの読み込み機能（pkg/script）を既に実装しており、次のステップとして字句解析、構文解析、OpCode生成の3つのフェーズからなるコンパイラパイプラインが必要です。

## 用語集

- **Lexer（字句解析器）**: ソースコードをトークン列に分解するコンポーネント
- **Parser（構文解析器）**: トークン列を抽象構文木（AST）に変換するコンポーネント
- **Compiler（コンパイラ）**: ASTからOpCodeを生成するコンポーネント
- **OpCode**: 仮想マシンで実行可能な命令列
- **AST（抽象構文木）**: プログラムの構造を木構造で表現したもの
- **Token（トークン）**: ソースコードの最小単位（キーワード、識別子、演算子など）
- **TFY_Script**: .TFY拡張子を持つC言語ライクなスクリプト言語
- **VM（仮想マシン）**: OpCodeを実行するランタイム環境
- **Event_Handler**: mes()ブロックで定義されるイベント駆動の処理
- **Step_Block**: step()構文で定義される時間制御されたコマンドシーケンス

## 要件

### 要件1: スクリプトファイルの読み込み

**ユーザーストーリー:** 開発者として、TFYスクリプトファイルを読み込めるようにしたい。そうすることで、OpCodeにコンパイルできるようになる。

#### 受け入れ基準

1.1. TFYスクリプトファイルのパスが提供されたとき、コンパイラは既存のscript.Loaderを使用してスクリプト内容を読み込む
1.2. ディレクトリ内に複数のTFYファイルが存在するとき、コンパイラはすべてのTFYファイルを読み込み、mainエントリーポイントを特定する
1.3. TFYファイルが#includeディレクティブで別のファイルをインクルードしているとき、コンパイラはインクルードされたファイルを再帰的に読み込む
1.4. TFYファイルが読み込めない場合、コンパイラはファイルパスを含む説明的なエラーを返す
1.5. コンパイラは既存の変換機能を使用してShift-JISエンコードされたファイルを正しく処理する

### 要件2: 字句解析（Lexer）

**ユーザーストーリー:** 開発者として、TFYスクリプトのソースコードをトークン化したい。そうすることで、パーサーがASTに変換できるようになる。

#### 受け入れ基準

2.1. LexerがUTF-8エンコードされたソースコードを受け取ったとき、トークンのシーケンスにトークン化する
2.2. Lexerがキーワード（int, if, for, while, mes, stepなど）を検出したとき、キーワードトークンとして識別する（大文字小文字を区別しない）
2.3. Lexerが識別子を検出したとき、識別子名を持つIDENTトークンを作成する
2.4. Lexerが整数リテラル（10進数または0xプレフィックス付き16進数）を検出したとき、パースされた値を持つINT_LITトークンを作成する
2.5. Lexerが浮動小数点リテラルを検出したとき、パースされた値を持つFLOAT_LITトークンを作成する
2.6. Lexerがダブルクォートで囲まれた文字列リテラルを検出したとき、文字列内容を持つSTRING_LITトークンを作成する
2.7. Lexerが演算子（+, -, *, /, %, ==, !=, <, <=, >, >=, &&, ||, !）を検出したとき、適切な演算子トークンを作成する
2.8. Lexerが区切り文字（(, ), {, }, [, ], ,, ;）を検出したとき、適切な区切り文字トークンを作成する
2.9. Lexerが単一行コメント（//）を検出したとき、次の行までスキップする
2.10. Lexerが複数行コメント（/* */）を検出したとき、閉じる*/までスキップする
2.11. Lexerが空白文字を検出したとき、トークンを作成せずにスキップする
2.12. Lexerが不正な文字を検出したとき、ILLEGALトークンを作成する
2.13. Lexerが入力の終端に達したとき、EOFトークンを作成する
2.14. すべてのトークンについて、Lexerはエラー報告のために行番号と列番号を記録する
2.15. Lexerがプリプロセッサディレクティブ（#info, #include）を検出したとき、DIRECTIVEトークンを作成する
2.16. Lexerが#infoディレクティブを検出したとき、行末までをディレクティブ内容として読み込む
2.17. Lexerが#includeディレクティブを検出したとき、インクルードするファイル名を含むトークンを作成する

### 要件3: 構文解析（Parser）

**ユーザーストーリー:** 開発者として、トークン列をASTに解析したい。そうすることで、コンパイラが構造化されたプログラム表現からOpCodeを生成できるようになる。

#### 受け入れ基準

3.1. Parserがトークン列を受け取ったとき、プログラム構造を表すASTを構築する
3.2. Parserが変数宣言（int x, y[]; str s;）を検出したとき、型と変数名を持つVarDeclarationノードを作成する
3.3. Parserがサイズ付き配列宣言（int arr[10]）を検出したとき、配列フラグとサイズ式を持つVarDeclarationノードを作成する
3.4. Parserが関数定義（name(params){body}）を検出したとき、名前、パラメータ、本体を持つFunctionStatementノードを作成する
3.5. Parserが代入文（x = expr）を検出したとき、ターゲットと値を持つAssignStatementノードを作成する
3.6. Parserが配列代入（arr[i] = value）を検出したとき、IndexExpressionターゲットを持つAssignStatementノードを作成する
3.7. Parserがif文を検出したとき、条件、結果、オプションの代替を持つIfStatementノードを作成する
3.8. Parserがforループを検出したとき、初期化、条件、後処理、本体を持つForStatementノードを作成する
3.9. Parserがwhileループを検出したとき、条件と本体を持つWhileStatementノードを作成する
3.10. Parserがswitch文を検出したとき、値、caseクローズ、オプションのdefaultを持つSwitchStatementノードを作成する
3.11. Parserがmes(EVENT)ブロックを検出したとき、イベントタイプと本体を持つMesStatementノードを作成する
3.12. Parserがstep()文またはブロックを検出したとき、カウントとオプションの本体を持つStepStatementノードを作成する
3.13. Parserが関数呼び出しを検出したとき、関数名と引数を持つCallExpressionノードを作成する
3.14. Parserが演算子を含む式を検出したとき、演算子の優先順位を尊重して適切な式ノードを作成する
3.15. Parserが構文エラーを検出したとき、行番号と列番号を含むエラーメッセージを記録する
3.16. Parserが構文エラーを検出したとき、エラー行の前後2行のソースコードコンテキストを含める
3.17. Parserが#infoディレクティブを検出したとき、InfoDirectiveノードを作成してメタデータを保持する
3.18. Parserが#includeディレクティブを検出したとき、IncludeDirectiveノードを作成してファイル名を保持する
3.19. Parserが関数呼び出しの引数として配列参照（arr[]）を検出したとき、配列全体を渡す引数として解析する

### 要件4: OpCode生成（Compiler）

**ユーザーストーリー:** 開発者として、ASTからOpCodeを生成したい。そうすることで、VMがコンパイルされたプログラムを実行できるようになる。

#### 受け入れ基準

4.1. CompilerがASTを受け取ったとき、OpCode命令のシーケンスを生成する
4.2. Compilerが変数代入を検出したとき、変数名と値を持つOpAssign命令を生成する
4.3. Compilerが配列代入を検出したとき、配列、インデックス、値を持つOpArrayAssign命令を生成する
4.4. Compilerが関数呼び出しを検出したとき、関数名と引数を持つOpCall命令を生成する
4.5. Compilerがif文を検出したとき、条件、結果、代替のOpCodeシーケンスを持つOpIf命令を生成する
4.6. Compilerがforループを検出したとき、初期化、条件、後処理、本体のOpCodeシーケンスを持つOpFor命令を生成する
4.7. Compilerがwhileループを検出したとき、条件と本体のOpCodeシーケンスを持つOpWhile命令を生成する
4.8. Compilerがswitch文を検出したとき、値、caseクローズ、defaultのOpCodeシーケンスを持つOpSwitch命令を生成する
4.9. Compilerがbreak文を検出したとき、OpBreak命令を生成する
4.10. Compilerがcontinue文を検出したとき、OpContinue命令を生成する
4.11. Compilerがreturn文を検出したとき、オプションの戻り値を持つOpCall命令（"return"）を生成する
4.12. Compilerがmes(EVENT)ブロックを検出したとき、イベントタイプと本体のOpCodeシーケンスを持つOpRegisterEventHandler命令を生成する
4.13. Compilerがstep(n)文を検出したとき、ステップカウントを持つOpWait命令を生成する
4.14. Compilerがstep(n)ブロックを検出したとき、OpSetStep命令に続いてコマンドとOpWait命令のフラットなシーケンスを生成する
4.15. Compilerがstepブロック内の空文（カンマ）を検出したとき、連続するカンマの数を持つOpWait命令を生成する
4.16. Compilerが式を検出したとき、評価のための適切なOpCode（OpBinaryOp、OpUnaryOp、OpArrayAccessなど）を生成する
4.17. Compilerがコンパイルエラーを検出したとき、エラーメッセージを記録する
4.18. Compilerが配列参照（arr[]）を検出したとき、配列全体を参照する変数として扱う

### 要件5: エラーハンドリング

**ユーザーストーリー:** 開発者として、コンパイルが失敗したときに明確なエラーメッセージが欲しい。そうすることで、スクリプトの問題を素早く特定して修正できるようになる。

#### 受け入れ基準

5.1. Lexerが不正な文字を検出したとき、文字、行番号、列番号を報告する
5.2. Parserが構文エラーを検出したとき、期待されるトークンタイプ、実際のトークンタイプ、行番号、列番号を報告する
5.3. Parserが構文エラーを検出したとき、エラー行の前後2行のソースコードコンテキストを含める
5.4. Parserが構文エラーを検出したとき、エラー列を示すポインタ（^）を含める
5.5. Compilerが未知のASTノードタイプを検出したとき、エラーメッセージにノードタイプを報告する
5.6. いずれかのコンパイルフェーズが失敗したとき、システムはすべてのエラーを収集して呼び出し元に返す
5.7. コンパイルが成功したとき、システムは空のエラーリストを返す

### 要件6: 統合とパイプライン

**ユーザーストーリー:** 開発者として、統一されたコンパイルパイプラインが欲しい。そうすることで、FILLYスクリプトをソースからOpCodeに簡単にコンパイルできるようになる。

#### 受け入れ基準

6.1. システムはLexer、Parser、Compilerをチェーンするコンパイルパイプラインを提供する
6.2. パイプラインがソースコードを受け取ったとき、Lexer → Parser → Compilerの順序で実行する
6.3. いずれかのフェーズが失敗したとき、システムはパイプラインを停止し、蓄積されたすべてのエラーを返す
6.4. すべてのフェーズが成功したとき、システムは生成されたOpCodeシーケンスを返す
6.5. システムは既存のスクリプト読み込み機能（pkg/script/script.go）と統合する
6.6. 複数のスクリプトファイルを処理するとき、システムは各ファイルを独立してコンパイルする
6.7. #includeディレクティブを処理するとき、システムはプリプロセス中にそれらを処理する
6.8. プリプロセッサは#includeディレクティブを検出したとき、指定されたファイルの内容を展開する
6.9. プリプロセッサは循環参照を検出したとき、エラーを報告する
6.10. プリプロセッサは同じファイルが複数回インクルードされた場合、重複を防ぐ

### 要件13: アプリケーション統合

**ユーザーストーリー:** 開発者として、アプリケーション起動時にスクリプトが自動的にコンパイルされてほしい。そうすることで、タイトル実行時にOpCodeが利用可能になる。

#### 受け入れ基準

13.1. アプリケーション（pkg/app/app.go）がスクリプトを読み込んだ後、コンパイラを呼び出してOpCodeを生成する
13.2. コンパイルが成功したとき、生成されたOpCodeをログに出力する（デバッグレベル）
13.3. コンパイルが失敗したとき、エラーメッセージを表示してアプリケーションを終了する
13.4. 複数のスクリプトファイルが存在するとき、main関数を含むファイルをエントリーポイントとして特定する
13.5. main関数が見つからないとき、エラーメッセージを表示する

### 要件14: エントリーポイントの解決

**ユーザーストーリー:** 開発者として、エントリーポイントとなるTFYファイルを明示的に指定したい。そうすることで、同一ディレクトリ内に複数の独立したプログラムがある場合でも正しくコンパイルできる。

#### 受け入れ基準

14.1. ビルド時にユーザーがエントリーポイントとなるTFYファイルを指定できる
14.2. エントリーポイントが指定されない場合、システムはmain関数を含むファイルを自動検出する
14.3. 自動検出でmain関数が複数のファイルに存在するとき、エラーを報告してユーザーに明示的な指定を求める
14.4. 自動検出でmain関数が見つからないとき、エラーを報告する
14.9. main関数検出時にパースエラーが発生したファイルはスキップして検出を続行する
14.5. エントリーポイントファイルから#includeされるファイルのみをコンパイル対象とする
14.6. エントリーポイントから直接・間接的にincludeされていないファイルはコンパイル対象外とする
14.7. 循環参照が検出されたとき、エラーを報告する
14.8. タイトル設定ファイル（title.json）でエントリーポイントを記録できる

### 要件15: タイトルメタデータ

**ユーザーストーリー:** ユーザーとして、タイトル一覧でタイトル名や説明を見たい。そうすることで、どのタイトルを選ぶか判断できる。

#### 受け入れ基準

15.1. システムはTFYファイルから#infoディレクティブを抽出してメタデータとして保持する
15.2. 抽出されたメタデータにはINAM（タイトル名）、ICOP（著作権）、ISBJ（説明）、ICMT（コメント）を含む
15.3. タイトル一覧表示時、INAMがあればそれを表示名として使用する
15.4. INAMがない場合はディレクトリ名を表示名として使用する
15.5. メタデータ抽出はフルコンパイルせずにLexerのみで軽量に行う

**ユーザーストーリー:** VM開発者として、明確に定義されたOpCode命令セットが欲しい。そうすることで、実行エンジンを正しく実装できるようになる。

#### 受け入れ基準

7.1. OpCodeは変数代入のためのOpAssignをサポートする
7.2. OpCodeは配列要素代入のためのOpArrayAssignをサポートする
7.3. OpCodeは配列要素アクセスのためのOpArrayAccessをサポートする
7.4. OpCodeは関数呼び出しのためのOpCallをサポートする
7.5. OpCodeは二項演算（+, -, *, /, %, ==, !=, <, <=, >, >=, &&, ||）のためのOpBinaryOpをサポートする
7.6. OpCodeは単項演算（-, !）のためのOpUnaryOpをサポートする
7.7. OpCodeは条件実行のためのOpIfをサポートする
7.8. OpCodeはforループのためのOpForをサポートする
7.9. OpCodeはwhileループのためのOpWhileをサポートする
7.10. OpCodeはswitch文のためのOpSwitchをサポートする
7.11. OpCodeはループからの脱出のためのOpBreakをサポートする
7.12. OpCodeは次のループ反復への継続のためのOpContinueをサポートする
7.13. OpCodeはmes()ブロックのためのOpRegisterEventHandlerをサポートする
7.14. OpCodeはstep()タイミング制御のためのOpWaitをサポートする
7.15. OpCodeはstep()ブロックでのステップ期間設定のためのOpSetStepをサポートする
7.16. すべてのOpCode命令について、操作タイプを示すCmdフィールドを含める
7.17. すべてのOpCode命令について、操作引数を含むArgsフィールドを含める

### 要件8: 変数スコープとシンボル管理

**ユーザーストーリー:** 開発者として、適切な変数スコープ管理が欲しい。そうすることで、ローカル変数とグローバル変数が正しく動作するようになる。

#### 受け入れ基準

8.1. 変数がトップレベルで宣言されたとき、システムはそれをグローバル変数として扱う
8.2. 変数が関数内で宣言されたとき、システムはそれをローカル変数として扱う
8.3. 関数パラメータが宣言されたとき、システムはそれをその関数のスコープ内のローカル変数として扱う
8.4. 変数が事前の宣言なしに代入されたとき、システムは動的に作成する（FILLYの動的型付け動作）
8.5. 変数がアクセスされたとき、システムは現在のスコープから最初に解決し、次に親スコープを解決する
8.6. 関数が定義されたとき、システムはそれをグローバル関数テーブルに登録する
8.7. mes()イベントハンドラが定義されたとき、システムはそれをイベントハンドラテーブルに登録する

### 要件9: 特殊構文のサポート

**ユーザーストーリー:** 開発者として、FILLY固有の構文機能のサポートが欲しい。そうすることで、既存のFILLYスクリプトが正しくコンパイルされるようになる。

#### 受け入れ基準

9.1. Parserがmes(EVENT)ブロックを検出したとき、EVENTを以下のいずれかとして認識する：TIME, MIDI_TIME, MIDI_END, KEY, CLICK, RBDOWN, RBDBLCLK, USER
9.2. Parserがカンマを含むstep()ブロックを検出したとき、各カンマをwait命令として解釈する
9.3. Parserがstep()ブロック内の連続するカンマを検出したとき、それらを複数のwaitステップとしてカウントする
9.4. Parserがend_stepキーワードを検出したとき、stepブロックの終了マーカーとして扱う
9.5. Parserがdel_me、del_us、del_allキーワードを検出したとき、関数呼び出しとして扱う
9.6. Parserがデフォルト値付きの関数パラメータ（int time=1）を検出したとき、デフォルト値式を解析する
9.7. Parserが配列パラメータ（int arr[]）を検出したとき、配列構文を認識する
9.8. Lexerがキーワードを検出したとき、大文字小文字を区別しないマッチングを行う（TIME, time, Timeはすべて有効）
9.9. Parserが'function'キーワードなしの関数定義（name(params){body}）を検出したとき、関数定義として認識する
9.10. Parserが式コンテキストでキーワードでもある識別子（int time=1）を検出したとき、識別子としてキーワードを許可する

### 要件10: コンパイラAPI

**ユーザーストーリー:** システムインテグレーターとして、TFYスクリプトをコンパイルするためのクリーンなAPIが欲しい。そうすることで、コンパイラをランタイムシステムに統合できるようになる。

#### 受け入れ基準

10.1. コンパイラはスクリプトパスを受け取りOpCodeまたはエラーを返すCompile関数を提供する
10.2. コンパイラはスクリプト内容を文字列として受け取りOpCodeまたはエラーを返すCompileString関数を提供する
10.3. コンパイラはコンパイラ設定オプションを受け入れるCompileWithOptions関数を提供する
10.4. コンパイラは仮想マシンに適した形式でコンパイル済みOpCodeを返す
10.5. コンパイラはスレッドセーフであり、複数のスクリプトの同時コンパイルをサポートする

### 要件11: OpCodeフォーマット

**ユーザーストーリー:** VM開発者として、明確に定義されたOpCodeフォーマットが欲しい。そうすることで、コンパイル済みプログラムを効率的に実行できるようになる。

#### 受け入れ基準

11.1. OpCodeフォーマットはCmd（string）とArgs（[]any）フィールドを持つ構造体を使用する
11.2. Cmdフィールドはコマンドタイプを文字列として含む（例："Assign"、"Call"、"If"、"LoadPic"）
11.3. Argsフィールドは任意の型を保持できる引数のスライスを含む（整数、文字列、ネストされたOpCode）
11.4. 関数呼び出しを表すとき、Cmdは"Call"であり、Args[0]は関数名を含む
11.5. OpCodeフォーマットは即値（整数、文字列、16進数カラー）をサポートする
11.6. OpCodeフォーマットは名前による変数参照をサポートする
11.7. OpCodeフォーマットは制御フローのためのジャンプターゲット（ラベルまたはアドレス）をサポートする
11.8. OpCodeフォーマットは複雑な式のためのネストされたOpCode構造をサポートする

### 要件12: テスト容易性

**ユーザーストーリー:** 開発者として、テスト可能なコンパイラコンポーネントが欲しい。そうすることで、自動テストを通じて正確性を検証できるようになる。

#### 受け入れ基準

12.1. Lexerはソースコード入力とトークンシーケンス出力で独立してテスト可能である
12.2. Parserはトークンシーケンス入力とAST出力で独立してテスト可能である
12.3. Compilerは AST入力とOpCodeシーケンス出力で独立してテスト可能である
12.4. システムは統合テストのためのサンプルFILLYスクリプトを提供する
12.5. システムはデバッグのために生成されたOpCodeを検査する方法を提供する
12.6. テスト時、システムはAST構造の等価性比較をサポートする
12.7. テスト時、システムはOpCodeシーケンスの等価性比較をサポートする

### 要件16: プリプロセッサ

**ユーザーストーリー:** 開発者として、`#include`ディレクティブを適切に処理したい。そうすることで、複数ファイルに分割されたスクリプトを正しくコンパイルできる。

#### 受け入れ基準

16.1. プリプロセッサはエントリーポイントファイルから処理を開始する
16.2. プリプロセッサは`#include "filename"`ディレクティブを検出したとき、指定されたファイルの内容を展開する
16.3. プリプロセッサは`#include`で指定されたファイルを再帰的に処理する
16.4. プリプロセッサは循環参照を検出したとき、エラーを報告する
16.5. プリプロセッサは同じファイルが複数回インクルードされた場合、重複を防ぐ（インクルードガード）
16.6. プリプロセッサはエントリーポイントから直接・間接的にインクルードされていないファイルを無視する
16.7. プリプロセッサは展開後のソースコードを返す
16.8. プリプロセッサはインクルードされたファイルのリストを返す（デバッグ用）
16.9. プリプロセッサはファイルが見つからない場合、エラーを報告する
