# アプリケーションスケルトン - 要件定義

## 概要
FILLYタイトル（マルチメディアオーサリングエンジン向けの作品）を実行するためのインタプリタのスケルトン実装。

**注意**: この要件は基本的なスケルトン実装のためのものです。以下の機能は仮実装であり、後続の要件定義で本実装に置き換えられる予定です：
- タイトル選択画面（仮実装：シンプルなリスト表示）
- 仮想デスクトップ（仮実装：背景色のみ表示）
- スクリプトファイルの読み込み（仮実装：読み込みとログ出力のみ、実行機能は含まない）

## 技術スタック
- 言語: Go
- GUIライブラリ: Ebitengine
- ロギング: log/slog (Go標準ライブラリ)
- 文字エンコーディング: golang.org/x/text/encoding/japanese

## 1. コマンドライン引数の解析

### 1.1 FILLYタイトルの指定
**ユーザーストーリー**: ユーザーとして、実行するFILLYタイトルを指定したい

**背景**:
FILLYタイトルは、アセットが格納されたディレクトリとして表現される。タイトルの指定方法は以下の3種類：
1. 単一のFILLYタイトルをビルド時にembedする（起動時に自動実行）
2. 複数のFILLYタイトルをビルド時にembedする（起動時に選択画面を表示）
3. 起動時にコマンドライン引数で単一のFILLYタイトルのディレクトリを指定する

**受け入れ基準**:
- コマンドライン引数でFILLYタイトルのディレクトリパスを指定できる（例: `son-et /path/to/title`）
- ビルド時に単一のFILLYタイトルがembedされている場合、引数なしで起動すると自動的にそのタイトルを実行する
- ビルド時に複数のFILLYタイトルがembedされている場合、引数なしで起動すると選択画面を表示する
- 指定されたディレクトリが存在しない場合は、エラーメッセージを表示して終了する
- FILLYタイトルが指定されていない、かつembedもされていない場合は、エラーメッセージを表示して終了する

### 1.2 タイムアウトオプション
**ユーザーストーリー**: 開発者として、指定した時間後にプログラムを自動終了させたい

**受け入れ基準**:
- `--timeout` または `-t` フラグで秒数を指定できる
- 指定された秒数が経過したら、プログラムが正常終了する
- タイムアウトが指定されない場合は、無期限に実行される
- 無効な値（負の数、非数値）が指定された場合は、エラーメッセージを表示して終了する

### 1.3 ログレベルオプション
**ユーザーストーリー**: 開発者として、ログの詳細度を制御したい

**受け入れ基準**:
- `--log-level` または `-l` フラグでログレベルを指定できる
- サポートするログレベル: `debug`, `info`, `warn`, `error`
- デフォルトのログレベルは `info`
- 無効なログレベルが指定された場合は、エラーメッセージを表示して終了する

### 1.4 ヘッドレスモードオプション

#### 1.4.1 ヘッドレスモードの強制
**ユーザーストーリー**: `--headless`フラグを指定してアプリケーションを実行するユーザーとして、グラフィカルディスプレイのない環境（サーバー、CI/CDパイプラインなど）で実行できるように、アプリケーションがGUIウィンドウを一切開かないことを望む

**用語**:
- **Headless_Mode（ヘッドレスモード）**: グラフィカルユーザーインターフェース（GUI）なしでアプリケーションが実行されるモード。標準入出力のみを使用して対話する
- **Title_Selection（タイトル選択）**: 複数のFILLYタイトルが利用可能な場合に、実行するタイトルを選択するプロセス
- **Virtual_Desktop（仮想デスクトップ）**: FILLYタイトルの実行環境を表示するGUIウィンドウ
- **GUI_Window（GUIウィンドウ）**: Ebitenゲームエンジンによって作成される任意のグラフィカルウィンドウ

**受け入れ基準**:
- WHEN `--headless`フラグが指定されている THEN Application は GUI_Window インスタンスを一切作成してはならない
- WHEN `--headless`フラグが指定されている AND タイトル選択が不要である THEN Application は Virtual_Desktop を開かずにスクリプト実行に直接進まなければならない
- WHEN `--headless`フラグが指定されている AND タイトル選択が必要である THEN Application は Title_Selection に標準入出力を使用しなければならない
- WHEN `--headless`フラグが指定されている THEN Application はコンソールベースの対話のみを使用してすべての操作を完了しなければならない

#### 1.4.2 ヘッドレスモードでのタイトル選択
**ユーザーストーリー**: 複数のタイトルが利用可能な状態でヘッドレスモードで実行するユーザーとして、GUIを必要とせずにどのタイトルを実行するか選択できるように、標準入出力を使用してタイトルを選択したい

**受け入れ基準**:
- WHEN Headless_Mode で Title_Selection が必要である THEN Application は利用可能なタイトルを標準出力に表示しなければならない
- WHEN Headless_Mode で Title_Selection が必要である THEN Application は標準入力からユーザー入力を受け付けなければならない
- WHEN Headless_Mode で有効なタイトル番号が入力された THEN Application はそのタイトルを選択して処理を続行しなければならない
- WHEN Headless_Mode で無効な入力が入力された THEN Application はエラーメッセージを表示して再度プロンプトを表示しなければならない
- WHEN Headless_Mode でユーザーが 'q' または 'Q' を入力した THEN Application は正常に終了しなければならない

#### 1.4.3 ヘッドレスモードでの仮想デスクトップの動作
**ユーザーストーリー**: ヘッドレスモードで実行するユーザーとして、ウィンドウを開こうとせずにアプリケーションが完了するように、仮想デスクトップフェーズを完全にスキップしたい

**受け入れ基準**:
- WHEN Headless_Mode がアクティブである THEN Application は Virtual_Desktop 表示フェーズをスキップしなければならない
- WHEN Headless_Mode がアクティブである AND Virtual_Desktop フェーズに到達した THEN Application はスキップアクションをログに記録して即座に戻らなければならない
- WHEN Headless_Mode がアクティブである THEN Application は Ebiten ウィンドウ作成関数を一切呼び出してはならない

#### 1.4.4 条件付きデスクトップ実行
**ユーザーストーリー**: 開発者として、ヘッドレスモードでGUIウィンドウが作成されないように、`runDesktop()`メソッドがウィンドウ操作の前にヘッドレスフラグをチェックすることを望む

**受け入れ基準**:
- WHEN Headless_Mode で `runDesktop()` が呼び出された THEN Application はウィンドウを作成せずに即座に戻らなければならない
- WHEN GUI モードで `runDesktop()` が呼び出された THEN Application は Virtual_Desktop ウィンドウを作成して表示しなければならない
- THE `runDesktop()` メソッドは、ウィンドウ作成関数を呼び出す前に Headless_Mode フラグをチェックしなければならない

#### 1.4.5 ウィンドウモジュールのヘッドレス安全性
**ユーザーストーリー**: 開発者として、ヘッドレスコードパスが誤ってGUI関数を呼び出さないように、ウィンドウモジュールがヘッドレス操作とGUI操作の明確な分離を提供することを望む

**受け入れ基準**:
- THE `window.Run()` 関数は Headless_Mode でない場合にのみ呼び出されなければならない
- THE `window.RunHeadless()` 関数は Headless_Mode の場合にのみ呼び出されなければならない
- WHEN `window.Run()` が呼び出された THEN Application は GUI_Window インスタンスを作成しなければならない
- WHEN `window.RunHeadless()` が呼び出された THEN Application は GUI_Window インスタンスを一切作成してはならない

### 1.5 ヘルプ表示
**ユーザーストーリー**: ユーザーとして、利用可能なオプションを確認したい

**受け入れ基準**:
- `--help` または `-h` フラグでヘルプメッセージを表示する
- ヘルプメッセージには、すべてのオプションの説明が含まれる
- ヘルプ表示後、プログラムは正常終了する

## 2. ロガーの初期化

### 2.1 ログレベルに応じたロガー初期化
**ユーザーストーリー**: 開発者として、指定したログレベルでログ出力を制御したい

**受け入れ基準**:
- コマンドライン引数で指定されたログレベルでロガーが初期化される
- ログ出力には、タイムスタンプとログレベルが含まれる
- 標準出力にログが出力される

### 2.2 構造化ログ
**ユーザーストーリー**: 開発者として、ログを解析しやすい形式で出力したい

**受け入れ基準**:
- ログは人間が読みやすい形式で出力される
- 各ログエントリには、時刻、レベル、メッセージが含まれる

## 3. Ebitengineウィンドウの表示

### 3.1 タイトル選択画面の表示（仮実装）
**ユーザーストーリー**: ユーザーとして、複数のFILLYタイトルがembedされている場合に選択画面から実行したいタイトルを選びたい

**注意**: この機能は仮実装です。後続の要件で、より洗練されたUI（アイコン表示、サムネイル等）に置き換えられる予定です。

**受け入れ基準**:
- 複数のFILLYタイトルがembedされている場合、起動時にタイトル選択画面が表示される
- 選択画面には、利用可能なFILLYタイトルの一覧がリスト形式で表示される
- 上下矢印キーで選択項目を移動できる
- Enterキーでタイトルを選択すると、そのタイトルの実行に移行する
- GUIモードでは、選択画面はEbitengineウィンドウ内に表示される（背景色: #0087C8）
- ヘッドレスモードでは、標準入出力を使用したテキストベースの選択画面を表示する
- 選択画面でEscキーまたはCtrl+Cで終了できる

### 3.2 仮想デスクトップの表示（仮実装）
**ユーザーストーリー**: ユーザーとして、FILLYタイトル実行時に仮想デスクトップが表示されることを確認したい

**注意**: この機能は仮実装です。後続の要件で、実際のFILLYタイトルのレンダリング機能が追加される予定です。

**受け入れ基準**:
- FILLYタイトルが選択または指定された後、Ebitengineの仮想デスクトップウィンドウが表示される（ヘッドレスモードでない場合）
- ウィンドウサイズは 1024x768 ピクセル
- ウィンドウタイトルは "FILLY Interpreter"
- ウィンドウの背景色は #0087C8（現時点では背景色のみ表示）
- ヘッドレスモードが指定された場合は、ウィンドウは表示されない

### 3.3 ウィンドウのクローズ処理
**ユーザーストーリー**: ユーザーとして、仮想デスクトップを閉じたらプログラムが終了してほしい

**受け入れ基準**:
- 仮想デスクトップの閉じるボタンをクリックすると、プログラムが正常終了する
- 終了時に適切なクリーンアップ処理が実行される

### 3.4 タイムアウトとの統合
**ユーザーストーリー**: 開発者として、タイムアウトが指定された場合は自動的に仮想デスクトップが閉じてほしい

**受け入れ基準**:
- `--timeout` が指定された場合、指定時間経過後に仮想デスクトップが閉じる
- タイムアウトによる終了も正常終了として扱われる
- タイムアウト前に仮想デスクトップを手動で閉じることもできる

## 4. スクリプトファイルの読み込み（仮実装）

**注意**: この機能は仮実装です。スクリプトファイルの読み込みとログ出力のみを行い、スクリプトの解析や実行機能は含みません。これらは後続の要件で追加される予定です。

### 4.1 スクリプトファイルの検出
**ユーザーストーリー**: 開発者として、FILLYタイトルディレクトリ内のスクリプトファイルを自動的に検出したい

**背景**:
- FILLYはWindows 3.1時代のソフトウェアであるため、ファイル名はcase-insensitiveで扱う
- スクリプトファイルの拡張子は `.TFY` または `.tfy`（大文字小文字を区別しない）
- C言語と同様に、main関数がエントリポイントとなる
- 他のスクリプトファイルは、mainを含むファイルからincludeされる形で使用される

**受け入れ基準**:
- 指定されたFILLYタイトルディレクトリ内のすべての `.TFY` ファイルを検出できる
- ファイル名の大文字小文字を区別せずに検出する（`.tfy`, `.TFY`, `.Tfy` など全て対応）
- スクリプトファイルが見つからない場合は、エラーメッセージを表示する
- 複数のスクリプトファイルが存在する場合は、すべて検出してログに出力する
- main関数を探すため、すべてのスクリプトファイルを読み込む
- ヘッドレスモードでもスクリプトファイルの読み込みは実行される

### 4.2 Shift-JISエンコーディングの対応
**ユーザーストーリー**: 開発者として、Shift-JISで書かれたスクリプトファイルを正しく読み込みたい

**背景**:
- Windows 3.1時代のファイルであるため、スクリプトファイルはShift-JISエンコーディングで書かれている可能性が高い

**受け入れ基準**:
- Shift-JISエンコーディングのスクリプトファイルを読み込める
- 読み込んだ内容をUTF-8に変換して内部で扱う
- エンコーディング変換エラーが発生した場合は、エラーメッセージを表示する
- 読み込んだスクリプトファイルの内容をログに出力する（デバッグレベル）

### 4.3 スクリプトファイルの読み込み確認
**ユーザーストーリー**: 開発者として、スクリプトファイルが正しく読み込まれたことを確認したい

**受け入れ基準**:
- スクリプトファイルの読み込みに成功したら、ファイル名とサイズをログに出力する
- 読み込んだスクリプトの内容（先頭100文字程度）をデバッグログに出力する
- 読み込みに失敗した場合は、エラーメッセージとスタックトレースをログに出力する

## 5. エラーハンドリング

### 5.1 起動時エラー
**ユーザーストーリー**: ユーザーとして、起動時のエラーを明確に知りたい

**受け入れ基準**:
- コマンドライン引数の解析エラーは、わかりやすいメッセージで表示される
- Ebitengineの初期化エラーは、適切にログ出力される
- スクリプトファイルの読み込みエラーは、ファイル名とエラー内容を含むメッセージで表示される
- エラー発生時は、非ゼロの終了コードで終了する

## 6. エントリーポイント指定

### 6.1 エントリーポイントの指定形式
**ユーザーストーリー**: 開発者として、エントリーポイントとなるTFYファイルをパスで指定したい。そうすることで、タブ補完を活用しながら簡単に指定できる。

**背景**:
FILLYタイトルのディレクトリには、複数の独立したプログラム（それぞれにmain関数を持つ）が含まれている場合がある。例えば`sab2`ディレクトリには`TOKYO.TFY`、`TOKYOE.TFY`、`TOKYOMS.TFY`など複数の独立したプログラムが存在する。

**受け入れ基準**:
- ビルドスクリプトでエントリーファイルのパスを直接指定できる（例: `samples/sab2/TOKYO.TFY`）
- エントリーファイルのパスから親ディレクトリを抽出し、それをembedすべきタイトルディレクトリとして認識する
- 従来通りディレクトリのみの指定も可能（後方互換性）
- ディレクトリのみ指定時に複数のmain関数が検出された場合は、エラーメッセージを表示して終了する
- 指定されたエントリーファイルが存在しない場合は、エラーメッセージを表示して終了する
- 複数タイトルの場合も同様に、各エントリーファイルのパスを指定できる

### 6.2 実行時のエントリーポイント指定
**ユーザーストーリー**: ユーザーとして、実行時にエントリーポイントとなるTFYファイルを指定したい。そうすることで、同一ディレクトリ内の複数プログラムから実行したいものを選べる。

**受け入れ基準**:
- コマンドライン引数でエントリーファイルのパスを指定できる（例: `./son-et samples/sab2/TOKYO.TFY`）
- エントリーファイルのパスから親ディレクトリをタイトルディレクトリとして認識する
- 従来通りディレクトリのみの指定も可能（後方互換性）
- ディレクトリのみ指定時に複数のmain関数が検出された場合は、エラーメッセージを表示して終了する（エントリーポイントの明示的な指定を促す）
- 指定されたエントリーファイルが存在しない場合は、エラーメッセージを表示して終了する

### 6.3 タイトル設定ファイル（title.json）
**ユーザーストーリー**: 開発者として、タイトルのエントリーポイント情報を設定ファイルに記録したい。そうすることで、embed後の実行時に正しいエントリーポイントが使用される。

**受け入れ基準**:
- ビルド時にエントリーポイントが指定された場合、`title.json`ファイルを生成する
- `title.json`には`entryFile`フィールドでエントリーポイントファイル名（ファイル名のみ）を記録する
- embed後の実行時に`title.json`が存在する場合、`entryFile`をエントリーポイントとして使用する
- `title.json`が存在しない場合は、従来通りmain関数を自動検出する

### 6.4 FillyTitleへのエントリーポイント情報追加
**ユーザーストーリー**: 開発者として、FillyTitle構造体にエントリーポイント情報を持たせたい。そうすることで、コンパイラに正しいエントリーポイントを渡せる。

**受け入れ基準**:
- FillyTitle構造体に`EntryFile`フィールドを追加する
- `title.json`からエントリーポイント情報を読み込む
- エントリーポイントが指定されていない場合は空文字列とする

## 7. プロジェクト構成

### 7.1 ディレクトリ構造
```
cmd/son-et/         # エントリーポイント
  main.go
pkg/
  app/              # アプリケーションのメインロジック
  cli/              # コマンドライン引数解析
  logger/           # ロガー
  window/           # Ebitengineウィンドウ管理
  title/            # FILLYタイトル管理
  script/           # スクリプトファイル読み込み
```

### 7.2 依存関係管理
**受け入れ基準**:
- `go.mod` でEbitengineの依存関係が管理される
- ロギングは標準ライブラリの `log/slog` を使用する
- Shift-JISエンコーディング変換には `golang.org/x/text/encoding/japanese` を使用する
- 必要最小限の外部依存のみを使用する
